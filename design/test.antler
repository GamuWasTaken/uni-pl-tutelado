
// Every expresion has a value, if no value is close then its safe to assume [] is its value
// 'let a = 4' has value [4]
// 'fn a|| {}' has value [], '{}' does to

let a = []
let b = 9
let c = [a, 8, b]

let a = 1+2+3+4-2*3/1+a

fn rev |x,y,z| {
    [ z,y,x ] 
}

let v = [1,2,3].rev // to call functions just use .func
let b = 1.rev       // err, rev expects 3 arguments, '1' has len 1

fn branchs |x| {
    (x = 3) 0              // Simple if, block is ran if x < 3
    (x > 2) (x < 10) 0 // And is just chaining
}

fn sum |..arr| { // use .. to accept any array len
    let sum = 0
    [arr -> x] sum = sum + x // expr runs for each element in arr
}

fn nesting {
    fn inside {
        
    }

}

fn slice |from, to, ..arr| {
    let out = []
    let i = 0
    [arr -> e] {
        (i > from) (i < to) {
            out = [out, e]
        }
        i = i + 1
    }
    out
}

fn range |from, to, step| { // function signatures are <name>/<paramlen> -> range/3
    let out = from
    [out -> e] (e < to) {
        out = [out, e + step]
    }
    out
}
fn range2 |from, to| { // range/2
    [from, to, 1].range
}
fn range3 |to| { // range/1
    [0, to].range2
}

fn iter3d {
    let dim = 10.range
    [dim -> x] [dim -> y] [dim -> z] {
        (x > y) (y > z) [0,0,0,0].@setBlock
        
        (x < y) [].@moveUp
        (z < x) [].@moveLeft
    }
}

let main = iter3d



